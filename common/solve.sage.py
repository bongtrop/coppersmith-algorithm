
# This file was *autogenerated* from the file ./solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_0p4 = RealNumber('0.4'); _sage_const_0p1604 = RealNumber('0.1604')
import itertools
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

def coron_trivariate(pol, X, Y, Z, l=_sage_const_2 , debug=False):
    P = PolynomialRing(ZZ, names=('x', 'y', 'z',)); (x, y, z,) = P._first_ngens(3)
    pol = pol(x,y,z)

    # Handle case where pol(0,0,0) == 0
    xoffset = _sage_const_0 

    while pol(xoffset,_sage_const_0 ,_sage_const_0 ) == _sage_const_0 :
        xoffset += _sage_const_1 

    pol = pol(x+xoffset,y,z)

    # Handle case where gcd(pol(0,0,0),X*Y*Z) != 1
    while gcd(pol(_sage_const_0 ,_sage_const_0 ,_sage_const_0 ), X) != _sage_const_1 :
        X = next_prime(X, proof=False)

    while gcd(pol(_sage_const_0 ,_sage_const_0 ,_sage_const_0 ), Y) != _sage_const_1 :
        Y = next_prime(Y, proof=False)

    while gcd(pol(_sage_const_0 ,_sage_const_0 ,_sage_const_0 ), Z) != _sage_const_1 :
        Z = next_prime(Z, proof=False)

    pol = P(pol/gcd(pol.coefficients())) # seems to be helpful
    p000 = pol(_sage_const_0 ,_sage_const_0 ,_sage_const_0 )

    # maximum degree of any variable
    delta = max(pol.degree(x),pol.degree(y),pol.degree(z))

    W = max(abs(i) for i in pol(x*X,y*Y,z*Z).coefficients())
    u = W + ((_sage_const_1 -W) % abs(p000))
    N = u*(X*Y*Z)**l # modulus for polynomials

    # Construct polynomials
    p000inv = inverse_mod(p000,N)
    polq = P(sum((i*p000inv % N)*j for i,j in zip(pol.coefficients(),
                                                 pol.monomials())))
    polynomials = []
    for i in range(delta+l+_sage_const_1 ):
        for j in range(delta+l+_sage_const_1 ):
            for k in range(delta+l+_sage_const_1 ):
                if _sage_const_0  <= i <= l and _sage_const_0  <= j <= l and _sage_const_0  <= k <= l:
                    polynomials.append(polq * x**i * y**j * z**k * X**(l-i) * Y**(l-j) * Z**(l-k))
                else:
                    polynomials.append(x**i * y**j * z**k * N)

    # Make list of monomials for matrix indices
    monomials = []
    for i in polynomials:
        for j in i.monomials():
            if j not in monomials:
                monomials.append(j)
    monomials.sort()

    # Construct lattice spanned by polynomials with xX, yY, zZ
    L = matrix(ZZ,len(monomials))
    for i in range(len(monomials)):
        for j in range(len(monomials)):
            L[i,j] = polynomials[i](X*x,Y*y,Z*z).monomial_coefficient(monomials[j])

    # makes lattice upper triangular
    # probably not needed, but it makes debug output pretty
    L = matrix(ZZ,sorted(L,reverse=True))

    if debug:
        print "Bitlengths of matrix elements (before reduction):"
        print L.apply_map(lambda x: x.nbits()).str()
        set_verbose(_sage_const_2 )

    L = L.LLL()

    if debug:
        print "Bitlengths of matrix elements (after reduction):"
        print L.apply_map(lambda x: x.nbits()).str()

    roots = []
    P2 = PolynomialRing(ZZ, names=('q',)); (q,) = P2._first_ngens(1)

    for i in range(L.nrows()-_sage_const_1 ):
        for j in range(i+_sage_const_1 ,L.nrows()):
            print "Trying rows %d, %d" % (i,j)
            pol2 = P(sum(map(mul, zip(L[i],monomials)))(x/X,y/Y,z/Z))
            pol3 = P(sum(map(mul, zip(L[j],monomials)))(x/X,y/Y,z/Z))

            r = pol.resultant(pol2, z)
            r2 = pol.resultant(pol3, z)
            r = r.resultant(r2,y)
            assert r.is_univariate()

            if r.is_constant(): # not independent
                continue

            r = r(q,_sage_const_0 ,_sage_const_0 ) # convert to univariate polynomial

            if len(r.roots()) > _sage_const_0 :
                for x0, _ in r.roots():
                    if x0 == _sage_const_0 :
                        continue
                    if debug:
                        print "Potential x0:",x0
                    for y0, _ in P2(r2(x0,q,_sage_const_0 )).roots():
                        if debug:
                            print "Potential y0:",y0
                        for z0, _ in P2(pol(x0,y0,q)).roots():
                            if debug:
                                print "Potential z0:",z0
                            if pol(x0-xoffset,y0,z0) == _sage_const_0 :
                                roots += [(x0-xoffset,y0,z0)]
    return roots

pubkey = RSA.importKey(open("public.pem").read())
n,e = pubkey.n, pubkey.e
print(n)
print(e)
gamma = _sage_const_0p4 
delta = _sage_const_0p1604 

P = PolynomialRing(ZZ, names=('x', 'y', 'z',)); (x, y, z,) = P._first_ngens(3)
X = floor(n**delta)
Y = floor(n**(delta+_sage_const_1 /_sage_const_2 -gamma))
Z = floor(n**(delta+_sage_const_1 /_sage_const_2 -gamma))

pol = e**_sage_const_2 *x**_sage_const_2  + e*x*(y+z-_sage_const_2 ) - (y+z-_sage_const_1 ) - (n-_sage_const_1 )*y*z

roots = coron_trivariate(pol, X, Y, Z, l=_sage_const_0 , debug=True)
if len(roots) > _sage_const_0 :
    print '!!!'
    x0,y0,z0 = roots[_sage_const_0 ]
    print(x0)
    print(y0)
    print(z0)
    d = int(x0)
    privkey = RSA.construct((n,e,d))
    cipher = PKCS1_OAEP.new(privkey)
    print(cipher.decrypt(open("flag.enc").read()))

